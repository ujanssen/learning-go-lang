package main

import (
	"errors"
	"fmt"
	"os"
	"github.com/nilshell/xmlrpc"
)


type XenAPIClient struct {
	Session  interface{}
	Host     string
	Url      string
	Username string
	Password string
	RPC      *xmlrpc.Client
}

func NewXenAPIClient(host string) (client XenAPIClient) {
	client.Host = host
	client.Url = "http://" + host
	client.RPC, _ = xmlrpc.NewClient(client.Url, nil)
	return
}

type APIResult struct {
	Status           string
	Value            interface{}
	ErrorDescription string
}

type XenAPIObject struct {
	Ref    string
	Client *XenAPIClient
}

func (c *XenAPIClient) RPCCall(result interface{}, method string, params []interface{}) (err error) {
	p := new(xmlrpc.Params)
	p.Params = params
	err = c.RPC.Call(method, *p, result)
	if err!=nil {fmt.Errorf("RPC Call Error: %s", err)}
	return err
}

func (client *XenAPIClient) APICall(result *APIResult, method string, params ...interface{}) (err error) {
	if client.Session == nil {
		return fmt.Errorf("No session. Unable to make call")
	}

	//Make a params slice which will include the session
	p := make([]interface{}, len(params)+1)
	p[0] = client.Session

	if params != nil {
		for idx, element := range params {
			p[idx+1] = element
		}
	}

	res := xmlrpc.Struct{}

	err = client.RPCCall(&res, method, p)

	if err != nil {
		return err
	}

	result.Status = res["Status"].(string)

	if result.Status != "Success" {
		return fmt.Errorf("API Error: %s", res["ErrorDescription"])
	} else {
		result.Value = res["Value"]
	}
	return
}


{{range .XapiObjects}}
{{if eq .Name "session" }}
{{ $xtype := .Name }}
// {{ .Description }}
type {{ .Name }} struct {
	{{range .Fields}}{{ .Name }}     {{ .Type }}
	{{end}}
}
{{range .Messages}}
{{ $message := . }}
{{if eq .Name "login_with_password" }}
func (client *XenAPIClient) {{ .Name }}({{range .Params}}{{ .Name }} {{ .Type }},{{end}})  (resultValue interface{}, err error){
	result := xmlrpc.Struct{}

//	params := make([]interface{}, {{ $message.ParamsLen }})
//	{{range $index, $element := .Params }}
//	params[{{$index}}] = {{$element.Name}}{{end}}

	params := make([]interface{}, 2)
	params[0] = client.Username
	params[1] = client.Password

	err = client.RPCCall(&result, "session.login_with_password", params)
	resultValue = result["Value"]

	return resultValue, err
}
{{end}}{{end}}{{end}}{{end}}

func (client *XenAPIClient) Login() (err error) {
	//Do loging call
	result := xmlrpc.Struct{}

	params := make([]interface{}, 2)
	params[0] = client.Username
	params[1] = client.Password

	err = client.RPCCall(&result, "session.login_with_password", params)
	if err == nil {
		// err might not be set properly, so check the reference
		if result["Value"] == nil {
			return errors.New ("Invalid credentials supplied")
		}
	}	
	client.Session = result["Value"]
	return err
}

const (
	XS_HOST   = "XS_HOST"
	XS_USER   = "XS_USER"
	XS_PASSWD = "XS_PASSWD"
)

func main() {
	fmt.Println("it compiles")
	host, user, passwd := os.Getenv(XS_HOST), os.Getenv(XS_USER), os.Getenv(XS_PASSWD)
	client := NewXenAPIClient(host)
	client.Username=user
	client.Password=passwd

	fmt.Println("NewXenAPIClient for: " + client.Host)
	fmt.Println("login_with_password: " + user + "/" + passwd)

	session, err := client.login_with_password(XS_USER, XS_PASSWD, "", "")
	fmt.Printf("err: %v\n", err)
	fmt.Printf("session: %+v\n", session)

	err = client.Login()
	fmt.Printf("err: %v\n", err)
	fmt.Printf("session: %+v\n", client.Session)
}
