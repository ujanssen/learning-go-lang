package main

import (
	"fmt"
	"os"
	"github.com/nilshell/xmlrpc"
)


type XenAPIClient struct {
	Session  interface{}
	Host     string
	Url      string
	Username string
	Password string
	RPC      *xmlrpc.Client
}

func NewXenAPIClient(host string) (client XenAPIClient) {
	client.Host = host
	client.Url = "http://" + host
	client.RPC, _ = xmlrpc.NewClient(client.Url, nil)
	return
}

type APIResult struct {
	Status           string
	Value            interface{}
	ErrorDescription string
}

type XenAPIObject struct {
	Ref    string
	Client *XenAPIClient
}

func (c *XenAPIClient) RPCCall(result interface{}, method string, params []interface{}) (err error) {
	p := new(xmlrpc.Params)
	p.Params = params
	err = c.RPC.Call(method, *p, result)
	if err!=nil {fmt.Errorf("RPC Call Error: %s", err)}
	return err
}

func (client *XenAPIClient) APICall(result *APIResult, method string, params ...interface{}) (err error) {
	if client.Session == nil {
		return fmt.Errorf("No session. Unable to make call")
	}

	//Make a params slice which will include the session
	p := make([]interface{}, len(params)+1)
	p[0] = client.Session

	if params != nil {
		for idx, element := range params {
			p[idx+1] = element
		}
	}

	res := xmlrpc.Struct{}

	err = client.RPCCall(&res, method, p)

	if err != nil {
		return err
	}

	result.Status = res["Status"].(string)

	if result.Status != "Success" {
		return fmt.Errorf("API Error: %s", res["ErrorDescription"])
	} else {
		result.Value = res["Value"]
	}
	return
}


{{range .XapiObjects}}
{{if eq .Name "session" }}
{{ $objectName := .Name }}
// {{ .Description }}
type {{ .Name }} struct {
	{{range .Fields}}{{ .Name }}     {{ .Type }}
	{{end}}
}
{{range .Messages}}
{{ $message := . }}
{{if eq .Name "login_with_password" }}
func (client *XenAPIClient) {{$objectName}}_{{.Name}}({{range .Params}}{{.Name}} {{ .Type }},{{end}})  (resultValue interface{}, err error){
	result := xmlrpc.Struct{}

    params := make([]interface{}, {{ $message.ParamsLen }})
    {{range $index, $element := .Params }}
    params[{{$index}}] = {{$element.Name}}{{end}}

	err = client.RPCCall(&result, "{{$objectName}}.{{.Name}}", params)
	resultValue = result["Value"]

	return resultValue, err
}
{{end}}{{end}}{{end}}

{{if eq .Name "VM" }}
{{ $objectName := .Name }}
{{range .Messages}}
{{ $message := . }}
{{if eq .Name "get_all" }}
func (client *XenAPIClient) {{$objectName}}_{{.Name}}({{range .Params}}{{.Name}} {{ .Type }},{{end}})  (resultValue interface{}, err error){
    result := xmlrpc.Struct{}

    params := make([]interface{}, {{ $message.ParamsLen }})
    {{range $index, $element := .Params }}
    params[{{$index}}] = {{$element.Name}}{{end}}

    err = client.RPCCall(&result, "{{$objectName}}.{{.Name}}", params)
    resultValue = result["Value"]

    return resultValue, err
}

{{end}}{{end}}{{end}}{{end}}

const (
	XS_HOST   = "XS_HOST"
	XS_USER   = "XS_USER"
	XS_PASSWD = "XS_PASSWD"
)

func main() {
	fmt.Println("it compiles")
	host, user, passwd := os.Getenv(XS_HOST), os.Getenv(XS_USER), os.Getenv(XS_PASSWD)
	client := NewXenAPIClient(host)

	fmt.Println("NewXenAPIClient for: " + client.Host)
	fmt.Println("login_with_password: " + user + "/" + passwd)

	session, err := client.session_login_with_password(user, passwd, "", "")
	fmt.Printf("err: %v\n", err)
	fmt.Printf("session: %+v\n", session)

    vms, err := client.VM_get_all(session)
    fmt.Printf("err: %v\n", err)
    fmt.Printf("vms: %+v\n", vms)

 //    client.Username=user
 //    client.Password=passwd
	// err = client.Login()
	// fmt.Printf("err: %v\n", err)
	// fmt.Printf("session: %+v\n", client.Session)
}
